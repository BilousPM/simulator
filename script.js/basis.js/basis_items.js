
"use strict";    //суворий режим коду...


//.length //властивісьть рядка., показує кількість символів.

// сутність.ім`я_метода()
//.toUpperCase()  //метод рядка.. переводить всі символи в верхній регістр..

undefined  // невизначенна змінна...

/* Типи данних :
* string    'string', "string";
* number     7, 21,55;
* boolean    true, false;     імена змінних, що містять буль ставлять запитання, і відповідь на нього - так або ні.;
* null        особливе значення, яке по суті означає ніщо;
* undefined   значення коли змінна оголошується, але не ініціалізується, її значення не визначено, їй присвоюється undefined.  (let username;)
*/
typeof //Оператор що використовується для отримання типу значення змінної. console.log(typeof "message"); // "string"

    
    /*
    --------- Виведення данних -------
    console.log()  - виведення данних в консоль;
    alert()   - виводить модальне вікно;

    --------- Введення данних-----------
    confirm() - виводить модальне вікно з повідомленням, і дві кнопки, Ok і Cancel;     const isComing = confirm("Please confirm hotel reservation");
    prompt() - виводить модальне вікно з полем введення і кнопками Ok і Cancel;     const value = prompt("Please enter a number!");
    */
    
    // Number(val) - приведення значення до числа;
    // NaN (Not a Number) - коли значення привести до числа неможливо;

    Number.parseInt() // парсить з рядка ціле число.   console.log(Number.parseInt("12.46qwe79")); // 12;
    Number.parseFloat() //парсить з рядка дробове число.   console.log(Number.parseFloat("12.46qwe79")); // 12.46;
Number.isNaN(val)  //для перевірки на число;
toFixed()  //результат скоротити до певного знаку після коми.    console.log((0.17 + 0.24).toFixed(2)); // 0.41  */
    

Math

Math.floor(num)// - повертає найменше ціле число. console.log(Math.floor(1.7)); // 1
Math.ceil(num) //- повертає найбільше ціле число. console.log(Math.ceil(1.2)); // 2
Math.round(num) //- повертає значення числа округленого до найближчого цілого. console.log(Math.round(1.2)); // 1
Math.max(num1, num2, ...) //- повертає найбільше ціле число з набору. console.log(Math.max(20, 10, 50, 40)); // 50
Math.min(num1, num2, ...) //- повертає найменше ціле число з набору. console.log(Math.min(20, 10, 50, 40)); // 10
Math.pow(base, exponent) //- піднесення до степеня. console.log(Math.pow(2, 4)); // 16
Math.random() //- повертає псевдовипадкове число в діапазоні [0, 1). console.log(Math.random()); // випадкове число між 0 і 1


// Властивості і методи рядків

length //довжина рядка.  console.log("Welcome to Bahamas!".length); // 19
.toUpperCase()  //метод рядка.. переводить всі символи в верхній регістр..
    .toLowerCase()  //метод рядка.. переводить всі символи в нижній регістр..
    .indexOf()  //Повертає позицію (індекс), на якій знаходиться перший збіг підрядка або -1, якщо нічого не знайдено.
.includes()  //Перевіряє, чи міститься підрядок в рядку, повертає буль - true або false;
    .endsWith()  //Дозволяє визначити, чи завершується рядок символами (підрядком), зазначеними в дужках, повертаючи true або false.
.replace() //Повертає новий рядок, в якому перше (replace) або усі збіги (replaceAll) підрядка замінені на вказане значення.
.replaceAll()
slice()
.slice ()  //Метод рядків slice (startIndex, endIndex) використовується для створення копії частини або всього рядка. Він робить копію елементів рядка від startIndex і до, але не включно endIndex і повертає новий рядок, не змінюючи оригінал.

/*
 6 хибних (falsy) значень, що приводяться до false у логічному перетворенні: 0, NaN, null, undefined, порожній рядок і false. Абсолютно все інше приводиться до true.*/


// Розгалуження

if (умова) { тіло if};
if (умова) {тіло if} else {тіло else };
if (умова) {тіло if} else if { тіло if} else {тіло else };

// Тернарний оператор...
const type = age >= 18 ? "adult" : "child";
// {/* <умова> ? <вираз_якщо_умова_правдива> : <вираз_якщо_умова_хибна></вираз_якщо_умова_хибна> */}

//Інструкція switch;  Для порівняння використовується оператор строгої рівності ===

switch (значення) {
  case значення:
    інструкції;
    break;

  case значення:
    інструкції;
    break;

  default:
    інструкції;
};

// Цикли...

while (condition) { /*код, тіло циклу (statement)*/ } //Цикл з передумовою
do {/* statement*/ } while (condition); //Цикл з постумовою
for (initialization; condition; post - expression) {/* statements*/ } //Цикл з лічильником for(let = i; i >= value; i += 1){};
// оператори....
continue //Перериває не увесь цикл, а тільки виконання поточної ітерації.
/*const number = 10;
for (let i = 0; i < number; i += 1) {
  if (i % 2 === 0) {
    continue;
  }
    console.log("Непарне i: ", i);*/
    break  //Перервати виконання циклу можна в будь-який момент;
/*for (let i = 0; i <= 5; i += 1) {
  console.log(i);

  if (i === 3) {
    console.log("Знайшли число 3, перериваємо виконання циклу");
    break;
  }
    }*/

for (const variable of iterable) {/* тіло циклу*/ };// Це хороша заміна циклу for, якщо не потрібен доступ до лічильника ітерації.

//Методи масиву....

.split(delimiter);// перетворює рядок в масив console.log(name.split("")); // ["M", "a", "n", "g", "o"]
.join(delimiter);//б'єднує елементи масиву у рядок
    .indexOf(value)//повертає перший індекс, в якому елемент зі значенням value був знайдений в масиві, або число -1..console.log(clients.indexOf("Poly"));
    .includes(value)// перевіряє, чи містить масив елемент зі значенням value;
    .push()//додає один або декілька елементів наприкінці масиву, 
    .pop()//видаляє останній елемент з кінця масиву і повертає видалений елемент;
    .unshift()//додає один або декілька елементів на початку масиву;
    .shift()//видаляє останній елемент на початку масиву і повертає видалений елемент;
    .slice(begin, end)//повертає новий масив, що містить копію частини вихідного масиву;
    .splice()//Видаляє, додає і замінює елементи у довільному місці масиву.
--.splice(position, num)//видалення.  повертає масив, що містить видалені елементи;
--.splice(position, 0, new_element_1, new_element_2, ...);//додавання;
--.splice(position, num, new_element_1, new_element_2, ...);//заміна;
oldClients.concat(newClients);//Об'єднує два або більше масивів в один;

// -------------------Function--------------
function declaration - //ключове слова function -> дієслово «Що зробити?» -> пара круглих дужок -> Тіло функції береться у фігурні дужки {}:  -> викликається за допомогою імені і пари круглих дужок;
    function multiply(x, y, z) {
        console.log(`Результат множення дорівнює ${x * y * z}`);
    };
multiply(1, 2, 3);
// араметри - перелік даних, які функція очікує на момент виклику;
// аргументи - значення для оголошених параметрів функції;
return - //використовується для передачі значення з тіла функції у зовнішній код;

    arguments//зміннf arguments, яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.

    // Перетворення псевдомасиву
    /*Використовуючи метод*/ Array.from(), /*який створить масив із псевдомасиву*/
    function fn() {
        // Змінна args буде містити повноцінний масив
        const args = Array.from(arguments);
    };


(function expression) //- звичайне оголошення змінної, значенням якої буде функція. Альтернативний спосіб оголошення функції.  
const multiply = function (x, y, z) {
  console.log(`Результат множення дорівнює ${x * y * z}`);
};

// Обєкти....
const name {
  ключ: значення,
  ключ:значення,
}
 //звернення до властивості обєкта....
 book['author']// Звернення до властивостей через крапку, (об'єкт.ім'я_властивості).
book.author//Звернення до властивостей через квадратні дужки, об'єкт["ім'я властивості"]

for...in // перебирання об'єктів використовується спеціальний цикл for...in, який перебирає ключі об'єкта object
for (key in object) {
  // інструкції
};
for (const key in book) {
  // Ключ
  console.log(key);
  // Значення властивості з таким ключем
  console.log(book[key]);
};

.hasOwnProperty(key);//концепція власних і невласних властивостей об'єкта;
Object.create(object);// створює і повертає новий об'єкт, зв'язуючи його з об'єктом
Object.keys(obj);//який приймає об'єкт і повертає масив ключів його власних властивостей
Object.values(obj); //повертає масив значень його власних властивостей.
Object.entries(obj);// повертає масив записів, кожен елемент якого, буде ще один масив з 2-х елементів: імені властивості і значення цієї властивості з об'єкта obj.

 ... (spread) //дозволяє розподілити колекцію елементів (масив, рядок або об'єкт) в місце, в якому очікується набір окремих значень. console.log(Math.max(...temps)); // 25
 Операція ... (spread)// дозволяє створити копію масиву або «склеїти» довільну кількість масивів в один новий
 Операція ... (spread)// дозволяє розподілити властивості довільної кількості об'єктів в один новий.

 Операція ... (rest) //дозволяє зібрати групу незалежних елементів у нову колекцію


//  Деструктуризація об'єктів

const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

// Деструктуризуємо
const { title, author, isPublic, rating, coverImage } = book;
// Зміна імені змінної : Спочатку пишемо ім'я властивості, з якої хочемо отримати значення, після чого ставимо двокрапку і пишемо ім'я змінної, в яку необхідно помістити значення цієї властивості.
const {
  name,
  tag,
  stats: { followers, views: userViews, likes: userLikes = 0 },
} = user;

// Деструктуризація масивів
/*Замість фігурних дужок {} використовуються квадратні [];
*Змінним, зазначеним у квадратних дужках [], будуть послідовно присвоюватися значення елементів масиву.*/
const rgb = [200, 255, 100];
const [red, green, blue] = rgb;

// Патерн «Об'єкт параметрів» допомагає вирішити проблему великої кількості параметрів, і аргументів, замінюючи набір параметрів всього одним об'єктом з іменованими властивостями, а  під час її виклику передаємо один об'єкт з необхідними властивостями.


//..Колбек-функції
Функція зворотного виклику (callback, колбек) - це функція, яка передається іншій функції як аргумент, а та, в свою чергу, викликає передану функцію.

Функція вищого порядку(higher order function) - функція, яка приймає у якості параметрів інші функції або повертає функцію у якості результату.


// Стрілочні функції
// Усі стрілки створюються як функціональний вираз, і якщо функція - не анонімна, її необхідно присвоювати змінній.
const add = (a, b, c) => {
  return a + b + c;
};

// Перебираючі методи масиву
array.method(callback[currentValue, index, array]);
array.method((item, idx, arr) => {
  // логіка, яка буде застосовуватися на кожній ітерації
});

.map(callback) //---Поелементо перебирає оригінальний масив.
/*--Не змінює оригінальний масив.
----Результат роботи колбек-функції записується у новий масив.
----Повертає новий масив однакової довжини.*/
массив.map((element, index, array) => {
  // Тіло колбек-функції
});

.flatMap(callback) //аналогічний методу map(), але застосовується у випадках, коли результат - це багатовимірний масив, який необхідно «розгладити»

  .filter(callback)//використовується для єдиної операції - фільтрації масиву, тобто, коли необхідно вибрати більше одного елемента з колекції за певним критерієм.
/* Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає новий масив.
Додає у масив, що повертається, елементи, які задовольняють умови колбек-функції.
Якщо колбек повернув true, елемент додається у масив, що повертається.
Якщо колбек повернув false, елемент не додається у масив, що повертається.
Якщо жоден елемент не задовольнив умову, повертає порожній масив.*/
const values = [51, -3, 27, 21, -68, 42, -37];
const positiveValues = values.filter(value => value >= 0);
console.log(positiveValues); // [51, 27, 21, 42]

/*Фільтрація унікальних елементів*/ array.indexOf(course)

.find() //кщо метод filter(callback) використовується для пошуку всіх елементів, що задовольняють умову, то метод find(callback) дозволяє знайти і повернути перший відповідний елемент, після чого перебирання масиву припиняється. Тобто він шукає до першого збігу.

масив.find((element, index, array) => {
  // Тіло колбек-функції
});
/*Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає перший елемент, що задовольняє умову, тобто коли колбек повертає true.
Якщо жоден елемент не задовольнив умову, тобто для всіх елементів колбек повернув false, метод повертає undefined.*/

.findIndex(callback) //- це сучасна заміна методу indexOf(). Дозволяє виконувати пошук за складнішими умовами, ніж просто рівність. Використовується як для пошуку у масиві примітивів, так і в масиві об'єктів.
масив.findIndex((element, index, array) => {
  // Тіло колбек-функції
});
/*Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає індекс першого елемента, що задовольняє умову, тобто, коли колбек повертає true.
Якщо жоден елемент не задовольняє умову, тобто для всіх елементів колбек повернув false, метод повертає -1.*/

.every()//Перевіряє, чи проходять всі елементи масиву тест колбек-функції. Повертає true або false
масив.every((element, index, array) => {
  // Тіло колбек-функції
});
/*Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає true, якщо всі елементи масиву задовольняють умову.
Повертає false, якщо хоча б один елемент масиву не задовольняє умову.
Перебирання масиву припиняється, якщо колбек повертає false.*/

.some()//Перевіряє, чи проходить хоча б один елемент масиву тест колбек-функції. Повертає true або false.
масив.some((element, index, array) => {
  // Тіло колбек-функції
});
/*Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає true, якщо хоча б один елемент масиву задовольняє умову.
Повертає false, якщо жоден елемент масиву не задовольняє умову.
Перебирання масиву припиняється, якщо колбек повертає true.*/

.reduce()//Метод reduce(callback, initialValue) використовується для послідовної обробки кожного елемента масиву із збереженням проміжного результату, як акумулятор. Трохи складніший за інші методи для засвоєння, але результат вартий того.
масив.reduce((previousValue(акамулятор), element, index, array) => {
  // Тіло колбек-функції
}, initialValue(стартове значення акамулятора));
/*Не змінює оригінальний масив.
Поелементо перебирає оригінальний масив.
Повертає все, що завгодно.
Робить все, що завгодно.*/


.sort()//сортує елементи масиву, але на відміну від інших методів перебирання, він сортує вихідний масив.

/*Сортує і змінює вихідний масив.
Повертає змінений масив, тобто посилання на відсортований вихідний.
За замовчуванням сортує за зростанням.
Сортування відбувається шляхом приведення значень до рядка і порівняння порядкових номерів у таблиці Unicode.  Через те, що сортується вихідний масив, порушується принцип чистоти функцій і не можна зручно створити декілька похідних колекцій на основі вихідної. Наприклад, створити колекцію, відсортовану за зростанням, а іншу - за спаданням. Тому перед сортуванням роблять повну копію вихідного масиву і сортують вже її.*/
const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort();

// Свій порядок сортування чисел
массив.sort((a, b) => {
  // Тіло колбек-функції
});
// Якщо виклик compareFunction(a, b) повертає будь-яке від'ємне значення, тобто a менше b, сортування поставить a перед b. Це сортування за зростанням.
const ascendingScores = [...scores].sort((a, b) => a - b);
// Якщо виклик compareFunction(a, b) повертає будь-яке додатне значення більше нуля, тобто b більше a, сортування поставить b перед a. Це сортування за спаданням.
const descendingScores = [...scores].sort((a, b) => b - a);

// Свій порядок сортування рядків
// Для сортування рядків в алфавітному порядку, за зростанням або спаданням, використовується метод рядків localeCompare().
firstString.localeCompare(secondString)
// Він викликається на рядку, який потрібно порівняти (firstString) з тим, що був переданий йому як аргумент (secondString).
/*Повертає від'ємне значення, якщо firstString повинен бути перед secondString.
Повертає додатне значення більше нуля, якщо firstString повинен бути після secondString.
Якщо рядки однакові, повертається нуль.*/
const students = ["Віка", "Андрій", "Олег", "Юля", "Борис", "Катя"];

const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
console.log(inAlphabetOrder); // ['Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля']

const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Віка', 'Борис', 'Андрій']


// Правила визначення this

// У глобальній області видимості, якщо скрипт виконується не в суворому режимі, this посилається на об'єкт window. В суворому режимі значення this, в глобальній області видимості, буде undefined.

// Якщо функція була викликана як метод об'єкта, то контекст буде посилатися на об'єкт, частиною якого є метод.

// Передаючи методи об'єкта як колбек-функції, контекст не зберігається. Колбек - це посилання на метод, яке присвоюється як значення параметра, що викликається без об'єкта.

// Стрілочні функції не мають свого this. На відміну від звичайних функцій, змінити значення this всередині стрілки після її оголошення - неможливо.




// Трапляються ситуації, коли функцію потрібно викликати в контексті об'єкта, при цьому функція не є його методом. Для цього у функцій є методи call, apply і bind.
// Методи call і apply викликають функцію «на місці», тобто відразу

Метод call();

//Метод call викличе функцію foo таким чином, що в this буде посилання на об'єкт obj, а також передасть аргументи arg1, arg2 тощо
foo.call(obj, arg1, arg2, ...)

//Метод apply - це аналог методу call за винятком того, що синтаксис передачі аргументів вимагає не перерахування, а масив, навіть якщо аргумент всього один.
foo.apply(obj, [arg1, arg2, ...])

Метод bind();
//Методи call і apply викликають функцію «на місці», тобто відразу. Але у разі колбек-функцій, коли необхідно не відразу викликати функцію, а передати посилання на неї, причому з прив'язаним контекстом, використовується метод bind.
foo.bind(obj, arg1, arg2, ...)
//Метод bind створює і повертає копію функції foo з прив'язаним контекстом obj і аргументами arg1, arg2 тощо. Утворюється копія функції, яку можна передати куди завгодно і викликати коли завгодно.



// Прототипне наслідування

Object.create(obj)// створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj.
isPrototypeOf() //перевіряє, чи є об'єкт animal прототипом для dog і чи повертає true або false
hasOwnProperty()//використовуємо метод obj.hasOwnProperty(prop), який повертає true, якщо властивість prop належить об'єкту obj, а не його прототипу, інакше - false.
Object.keys(obj)// поверне масив тільки власних ключів об'єкта obj, тому, на практиці використовують саме його, а не for...in.

